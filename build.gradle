import static groovy.io.FileType.FILES

plugins {
  id "base"
  id "org.asciidoctor.jvm.convert"
  id "jacoco"
  id "net.nemerosa.versioning"
  id "com.github.ben-manes.versions"
  id "spockbuild-common"
  id "spockbuild-ide-root"
}

description = "Spock Framework"

buildScan.tag "groovy-$variant"
buildScan.tag "Java $javaVersion"

task collectTestXml (group: 'Test reports') {
  description = "Collects the test xmls from every subproject into a new directory with subproject as name."
  def reportingProjects = subprojects.findAll()
  dependsOn(reportingProjects.tasks.collectMany{it.withType(Test)})


  doFirst {
    def target = file("$buildDir/collected-test-results")
    target.mkdirs()
    reportingProjects.each { rp ->
      rp.tasks.withType(Test).each { testTask ->
        def repSrc = testTask.reports.junitXml.destination

        def repTarget = file("$target/$rp.name-$repSrc.name")
        copy {
          from repSrc
          into repTarget
          include '**/*.xml'
        }
      }
    }
  }
}


task codeCoverageReport (type: JacocoReport, group: 'Coverage reports') {
  description = "Creates an aggregate coverage for the whole project."
  def reportingProjects = subprojects.findAll { it.name != "spock-bom" }
  dependsOn(reportingProjects.tasks.collectMany { it.withType(Test) })

  additionalSourceDirs.from(reportingProjects.sourceSets.main.allSource.srcDirs)
  additionalClassDirs.from(reportingProjects.sourceSets.main.output)
  executionData.from(files(reportingProjects.jacocoTestReport.executionData).filter { it.exists() })
  executionData.from(file('spock-specs/build/jacoco/compileTestGroovy.exec'))

  reports {
    html.enabled = true
    xml.enabled = true
    xml.destination file("${buildDir}/reports/jacoco/report.xml") // report must be here for codecov to pick it up
    csv.enabled = false
  }
}

if (gradle.startParameter.taskNames == ["ghActionsBuild"]) {
  gradle.startParameter.taskNames = ["build", "codeCoverageReport"]
}

if (gradle.startParameter.taskNames == ["ghActionsPublish"] || gradle.startParameter.taskNames == ["ghActionsDocs"] ) {
  def originalStartParameterTaskNames = gradle.startParameter.taskNames
  gradle.startParameter.taskNames = []
  boolean isMaster = System.getenv("GITHUB_REF") == "refs/heads/master"
  boolean isTag = System.getenv("GITHUB_REF")?.startsWith('refs/tags/spock-')
  if (!(System.getenv("GITHUB_EVENT_NAME") == "push"
          && (isMaster || isTag)
          && System.getenv("GITHUB_REPOSITORY") == 'spockframework/spock')) {
    throw new IllegalArgumentException("""ghActionsPublish can only be run on push to branch master or tag in repo spockframework/spock
      event: ${System.getenv("GITHUB_EVENT_NAME")}
      ref: ${System.getenv("GITHUB_REF")}
      repo: ${System.getenv("GITHUB_REPOSITORY")}""")
  }

  if (originalStartParameterTaskNames == ["ghActionsPublish"]) {
    if (javaVersion != javaVersions.min()) {
      throw new IllegalArgumentException("ghActionsPublish can only be run on Java ${javaVersions.min()} but was run on $javaVersion")
    }
    /*
      We want to release only snapshots directly from master, final releases will be tagged and then published from that tag.
     */
    if (snapshotVersion || isTag) {
      gradle.startParameter.taskNames += ["publish"]
    } // else {
      // disable tag release for now as this is done with a token, that doesn't trigger other workflows
      // gradle.startParameter.taskNames += ["tagRelease"]
      // }
  }

  if (originalStartParameterTaskNames == ["ghActionsDocs"] && (snapshotVersion || isTag)) {
    if (javaVersion != javaVersions.max()) {
      throw new IllegalArgumentException("ghActionsPublish can only be run on Java ${javaVersions.max()} but was run on $javaVersion")
    }
    if (variant != variants.max()) {
      throw new IllegalArgumentException("ghActionsPublish can only be run with variant ${variants.max()} but was run with $variant")
    }
    gradle.startParameter.taskNames += ["publishJavadoc", "publishDocs"]
  }
}

task publishJavadoc(type: Exec) {
  dependsOn "javadoc"
  commandLine "sh", "-c",
"""
  git config user.email "dev@forum.spockframework.org"
  git config user.name "Spock Framework Robot"
  git fetch origin +gh-pages:gh-pages
  git checkout gh-pages
  rm -rf javadoc/$variantLessVersion
  mkdir -p javadoc/$variantLessVersion
  cp -r build/javadoc/$variantLessVersion javadoc/
  git add javadoc
  git commit -qm "Publish javadoc/$variantLessVersion"
  git push "https://\$GITHUB_TOKEN@github.com/spockframework/spock.git" gh-pages 2>&1 | sed "s/\$GITHUB_TOKEN/xxx/g"
  git checkout master
"""
}
task publishDocs(type: Exec) {
  dependsOn "asciidoctor"
  commandLine "sh", "-c",
"""
  git config user.email "dev@forum.spockframework.org"
  git config user.name "Spock Framework Robot"
  git fetch origin +gh-pages:gh-pages
  git checkout gh-pages
  rm -rf docs/$variantLessVersion
  mkdir -p docs/$variantLessVersion
  cp -r build/docs/asciidoc/* docs/$variantLessVersion
  git add docs
  git commit -qm "Publish docs/$variantLessVersion"
  git push "https://\$GITHUB_TOKEN@github.com/spockframework/spock.git" gh-pages 2>&1 | sed "s/\$GITHUB_TOKEN/xxx/g"
  git checkout master
"""
}
task tagRelease(type: Exec) {
  commandLine "sh", "-c",
"""
  git config user.email "dev@forum.spockframework.org"
  git config user.name "Spock Framework Robot"
  git checkout master
  git tag -f spock-$variantLessVersion
  git push "https://\$GITHUB_TOKEN@github.com/spockframework/spock.git" spock-$variantLessVersion 2>&1 | sed "s/\$GITHUB_TOKEN/xxx/g"
"""
}

task javadoc(type: Javadoc) {
  title "Spock Framework API Documentation ($variantLessVersion)"
  destinationDir file("build/javadoc/$variantLessVersion")
  source subprojects.javadoc.source
  classpath = files(subprojects.javadoc.classpath)
}

configureJavadoc(javadoc)

task groovydoc(type: Groovydoc) {
  docTitle "Spock Framework API Documentation ($variantLessVersion)"
  windowTitle "Spock Framework API Documentation ($variantLessVersion)"
  destinationDir file("build/groovydoc/$variantLessVersion")
  source subprojects.groovydoc.source
  classpath = files(subprojects.groovydoc.classpath)
  groovyClasspath = project(":spock-core").groovydoc.groovyClasspath
}

configureGroovydoc(groovydoc)

asciidoctorj {
  modules {
    diagram.use()
  }
}

asciidoctor {
  sourceDir = "docs"
  baseDirFollowsSourceDir()
  logDocuments = true
  attributes "source-highlighter": "coderay", "linkcss": true, "sectanchors": true, "revnumber": variantLessVersion
  // also treats the included specs as inputs
  inputs.dir file("spock-specs/src/test/groovy/org/spockframework/docs")
  inputs.dir file("spock-spring/src/test/groovy/org/spockframework/spring/docs")
  inputs.dir file("spock-spring/src/test/resources/org/spockframework/spring/docs")
  inputs.dir file("spock-spring/boot-test/src/test/groovy/org/spockframework/boot")
  inputs.dir file("spock-spring/boot2-test/src/test/groovy/org/spockframework/boot2")
  inputs.dir file("spock-spring/spring3-test/src/test/groovy/org/spockframework/spring3")
  inputs.dir file("spock-spring/spring5-test/src/test/groovy/org/spockframework/spring5")

  doFirst {
    def errors = []
    sourceDir.eachFileRecurse(FILES) { file ->
      if (file.name =~ /(?<!^index)\.adoc$/) {
        (file.text =~ /<<([^>#]+\.adoc)#,[^>]+>>/)
          .collect { it[1] }
          .unique()
          .each {
            errors << "$file.name contains a cross-document link to $it without anchor, this will break in one-page variant"
          }
      }
    }
    if (errors) {
      throw new IllegalArgumentException(errors.join('\n'))
    }
  }
}


def configureJavadoc(task) {
  configure(task) {
    include "spock/**"
    configure(options) {
      options.addStringOption('source', '1.8')
      links "https://docs.oracle.com/javase/8/docs/api/"
      links "https://docs.groovy-lang.org/docs/groovy-$groovyVersion/html/gapi/"
      links "https://junit.org/junit4/javadoc/latest/"
      links "http://hamcrest.org/JavaHamcrest/javadoc/2.2/"
    }
  }
}

def configureGroovydoc(task) {
  configure(task) {
    include "spock/**"
  }
}
